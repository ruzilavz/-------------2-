<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>Reptile Lizard Autopilot</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000; /* фон, можно убрать если будет на твоём сайте */
    }
    #lizCanvas {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      background: transparent; /* чтобы фон сайта просвечивал */
      pointer-events: none;    /* не мешает кликам по сайту */
    }
  </style>
</head>
<body>
<div id="toggle-info" style="position: fixed; top: 10px; left: 10px; color: white; font-family: sans-serif; z-index: 10;">Press 'L' to toggle lizard</div>
<canvas id="lizCanvas"></canvas>

<script>
(function () {
  // ====== НАСТРОЙКИ, КОТОРЫЕ МОЖНО КРУТИТЬ ======
  const LINE_COLOR = "#ffffff";   // цвет ящера (меняешь сюда под сайт)
  const LINE_WIDTH = 1.0;         // толщина линий
  const BORDER_MARGIN = 60;       // отступ от краёв экрана

  // Автопилот — медленное, плавное движение
  const AUTO_BASE_SPEED = 45;     // скорость (px/сек) — если всё ещё быстро, уменьши
  const AUTO_STEP_MIN = 120;      // минимум шага до новой точки
  const AUTO_STEP_MAX = 220;      // максимум шага до новой точки
  const AUTO_IDLE_MIN = 0.7;      // минимум паузы (сек), когда стоит и "дышит"
  const AUTO_IDLE_MAX = 2.0;      // максимум паузы
  const AUTO_CIRCLE_SPEED = 0.9;  // скорость кружения (рад/сек)
  const AUTO_RADIUS_MIN = 60;     // радиус кружения мин
  const AUTO_RADIUS_MAX = 120;    // радиус кружения макс

  // ====== CANVAS ======
  const canvas = document.getElementById("lizCanvas");
  const ctx = canvas.getContext("2d");

  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  window.addEventListener("resize", resize);
  resize();

  ctx.strokeStyle = LINE_COLOR;
  ctx.lineWidth = LINE_WIDTH;

  // ====== ОРИГИНАЛЬНЫЕ КЛАССЫ ИЗ ТВОЕГО КОДА ======
  let segmentCount = 0;

  class Segment {
    constructor(parent, size, angle, range, stiffness) {
      segmentCount++;
      this.isSegment = true;
      this.parent = parent;
      if (typeof parent.children === "object") {
        parent.children.push(this);
      }
      this.children = [];
      this.size = size;
      this.relAngle = angle;
      this.defAngle = angle;
      this.absAngle = parent.absAngle + angle;
      this.range = range;
      this.stiffness = stiffness;
      this.updateRelative(false, true);
    }
    updateRelative(iter, flex) {
      this.relAngle =
        this.relAngle -
        2 * Math.PI *
          Math.floor((this.relAngle - this.defAngle) / (2 * Math.PI) + 0.5);

      if (flex) {
        this.relAngle = Math.min(
          this.defAngle + this.range / 2,
          Math.max(
            this.defAngle - this.range / 2,
            (this.relAngle - this.defAngle) / this.stiffness + this.defAngle
          )
        );
      }

      this.absAngle = this.parent.absAngle + this.relAngle;
      this.x = this.parent.x + Math.cos(this.absAngle) * this.size;
      this.y = this.parent.y + Math.sin(this.absAngle) * this.size;

      if (iter) {
        for (let i = 0; i < this.children.length; i++) {
          this.children[i].updateRelative(true, flex);
        }
      }
    }
    draw(iter) {
      ctx.beginPath();
      ctx.moveTo(this.parent.x, this.parent.y);
      ctx.lineTo(this.x, this.y);
      ctx.stroke();
      if (iter) {
        for (let i = 0; i < this.children.length; i++) {
          this.children[i].draw(true);
        }
      }
    }
    follow(iter) {
      const x = this.parent.x;
      const y = this.parent.y;
      const dx = this.x - x;
      const dy = this.y - y;
      const dist = Math.hypot(dx, dy) || 0.0001;

      this.x = x + (this.size * dx) / dist;
      this.y = y + (this.size * dy) / dist;

      this.absAngle = Math.atan2(this.y - y, this.x - x);
      this.relAngle = this.absAngle - this.parent.absAngle;
      this.updateRelative(false, true);

      if (iter) {
        for (let i = 0; i < this.children.length; i++) {
          this.children[i].follow(true);
        }
      }
    }
  }

  class LimbSystem {
    constructor(end, length, speed, creature) {
      this.end = end;
      this.length = Math.max(1, length);
      this.creature = creature;
      this.speed = speed;
      creature.systems.push(this);
      this.nodes = [];

      let node = end;
      for (let i = 0; i < length; i++) {
        this.nodes.unshift(node);
        node = node.parent;
        if (!node.isSegment) {
          this.length = i + 1;
          break;
        }
      }
      this.hip = this.nodes[0].parent;
    }
    moveTo(x, y) {
      this.nodes[0].updateRelative(true, true);

      let dist = Math.hypot(x - this.end.x, y - this.end.y);
      let len = Math.max(0, dist - this.speed);

      for (let i = this.nodes.length - 1; i >= 0; i--) {
        const node = this.nodes[i];
        const ang = Math.atan2(node.y - y, node.x - x);
        node.x = x + len * Math.cos(ang);
        node.y = y + len * Math.sin(ang);
        x = node.x;
        y = node.y;
        len = node.size;
      }

      for (let i = 0; i < this.nodes.length; i++) {
        const node = this.nodes[i];
        node.absAngle = Math.atan2(
          node.y - node.parent.y,
          node.x - node.parent.x
        );
        node.relAngle = node.absAngle - node.parent.absAngle;
        for (let j = 0; j < node.children.length; j++) {
          const childNode = node.children[j];
          if (!this.nodes.includes(childNode)) {
            childNode.updateRelative(true, false);
          }
        }
      }
    }
    update(x, y) {
      this.moveTo(x, y);
    }
  }

  class LegSystem extends LimbSystem {
    constructor(end, length, speed, creature) {
      super(end, length, speed, creature);
      this.goalX = end.x;
      this.goalY = end.y;
      this.step = 0;
      this.forwardness = 0;

      this.reach =
        0.9 *
        Math.hypot(this.end.x - this.hip.x, this.end.y - this.hip.y);

      const relAngle =
        this.creature.absAngle -
        Math.atan2(this.end.y - this.hip.y, this.end.x - this.hip.x);

      const normRel =
        relAngle - 2 * Math.PI * Math.floor(relAngle / (2 * Math.PI) + 0.5);

      this.swing =
        -normRel + (2 * (normRel < 0) - 1) * (Math.PI / 2);
      this.swingOffset = this.creature.absAngle - this.hip.absAngle;
    }
    update(x, y) {
      this.moveTo(this.goalX, this.goalY);

      if (this.step === 0) {
        const dist = Math.hypot(this.end.x - this.goalX, this.end.y - this.goalY);
        if (dist > 1) {
          this.step = 1;
          this.goalX =
            this.hip.x +
            this.reach *
              Math.cos(this.swing + this.hip.absAngle + this.swingOffset) +
            (2 * Math.random() - 1) * (this.reach / 2);
          this.goalY =
            this.hip.y +
            this.reach *
              Math.sin(this.swing + this.hip.absAngle + this.swingOffset) +
            (2 * Math.random() - 1) * (this.reach / 2);
        }
      } else if (this.step === 1) {
        const theta =
          Math.atan2(this.end.y - this.hip.y, this.end.x - this.hip.x) -
          this.hip.absAngle;
        const dist = Math.hypot(
          this.end.x - this.hip.x,
          this.end.y - this.hip.y
        );
        const forwardness2 = dist * Math.cos(theta);
        const dF = this.forwardness - forwardness2;
        this.forwardness = forwardness2;
        if (dF * dF < 1) {
          this.step = 0;
          this.goalX = this.hip.x + (this.end.x - this.hip.x);
          this.goalY = this.hip.y + (this.end.y - this.hip.y);
        }
      }
    }
  }

  class Creature {
    constructor(
      x,
      y,
      angle,
      fAccel,
      fFric,
      fRes,
      fThresh,
      rAccel,
      rFric,
      rRes,
      rThresh
    ) {
      this.x = x;
      this.y = y;
      this.absAngle = angle;

      this.fSpeed = 0;
      this.fAccel = fAccel;
      this.fFric = fFric;
      this.fRes = fRes;
      this.fThresh = fThresh;

      this.rSpeed = 0;
      this.rAccel = rAccel;
      this.rFric = rFric;
      this.rRes = rRes;
      this.rThresh = rThresh;

      this.children = [];
      this.systems = [];
    }
    follow(x, y) {
      const dist = Math.hypot(this.x - x, this.y - y);
      const ang = Math.atan2(y - this.y, x - this.x);

      let accel = this.fAccel;
      if (this.systems.length > 0) {
        let sum = 0;
        for (let i = 0; i < this.systems.length; i++) {
          sum += this.systems[i].step === 0 ? 1 : 0;
        }
        accel *= sum / this.systems.length;
      }
      this.fSpeed += accel * (dist > this.fThresh);
      this.fSpeed *= 1 - this.fRes;
      this.speed = Math.max(0, this.fSpeed - this.fFric);

      let dif = this.absAngle - ang;
      dif -= 2 * Math.PI * Math.floor(dif / (2 * Math.PI) + 0.5);

      if (Math.abs(dif) > this.rThresh && dist > this.fThresh) {
        this.rSpeed -= this.rAccel * (2 * (dif > 0) - 1);
      }
      this.rSpeed *= 1 - this.rRes;
      if (Math.abs(this.rSpeed) > this.rFric) {
        this.rSpeed -= this.rFric * (2 * (this.rSpeed > 0) - 1);
      } else {
        this.rSpeed = 0;
      }

      this.absAngle += this.rSpeed;
      this.absAngle -=
        2 * Math.PI * Math.floor(this.absAngle / (2 * Math.PI) + 0.5);

      this.x += this.speed * Math.cos(this.absAngle);
      this.y += this.speed * Math.sin(this.absAngle);

      // НЕ ВЫХОДИТ ЗА КРАЯ
      this.x = Math.max(0, Math.min(canvas.width, this.x));
      this.y = Math.max(0, Math.min(canvas.height, this.y));

      this.absAngle += Math.PI;
      for (let i = 0; i < this.children.length; i++) {
        this.children[i].follow(true, true);
      }
      for (let i = 0; i < this.systems.length; i++) {
        this.systems[i].update(x, y);
      }
      this.absAngle -= Math.PI;

      this.draw(true);
    }
    draw(iter) {
      const r = 4;
      ctx.beginPath();
      ctx.arc(
        this.x,
        this.y,
        r,
        Math.PI / 4 + this.absAngle,
        (7 * Math.PI) / 4 + this.absAngle
      );
      ctx.moveTo(
        this.x + r * Math.cos((7 * Math.PI) / 4 + this.absAngle),
        this.y + r * Math.sin((7 * Math.PI) / 4 + this.absAngle)
      );
      ctx.lineTo(
        this.x + r * Math.cos(this.absAngle) * Math.SQRT2,
        this.y + r * Math.sin(this.absAngle) * Math.SQRT2
      );
      ctx.lineTo(
        this.x + r * Math.cos(Math.PI / 4 + this.absAngle),
        this.y + r * Math.sin(Math.PI / 4 + this.absAngle)
      );
      ctx.stroke();

      if (iter) {
        for (let i = 0; i < this.children.length; i++) {
          this.children[i].draw(true);
        }
      }
    }
  }

  // ====== ОРИГИНАЛЬНЫЙ LIZARD С ДЕТАЛЯМИ ======
  let critter = null;

  function setupLizard(size, legs, tail) {
    const s = size;
    critter = new Creature(
      canvas.width / 2,
      canvas.height / 2,
      0,
      s * 10,
      s * 2,
      0.5,
      16,
      0.5,
      0.085,
      0.5,
      0.3
    );
    let spinal = critter;

    // Neck
    for (let i = 0; i < 6; i++) {
      spinal = new Segment(spinal, s * 4, 0, (3.1415 * 2) / 3, 1.1);
      for (let ii = -1; ii <= 1; ii += 2) {
        let node = new Segment(spinal, s * 3, ii, 0.1, 2);
        for (let iii = 0; iii < 3; iii++) {
          node = new Segment(node, s * 0.1, -ii * 0.1, 0.1, 2);
        }
      }
    }

    // Torso + legs
    for (let i = 0; i < legs; i++) {
      if (i > 0) {
        // Vertebrae + ribs
        for (let ii = 0; ii < 6; ii++) {
          spinal = new Segment(spinal, s * 4, 0, 1.571, 1.5);
          for (let iii = -1; iii <= 1; iii += 2) {
            let node = new Segment(spinal, s * 3, iii * 1.571, 0.1, 1.5);
            for (let iv = 0; iv < 3; iv++) {
              node = new Segment(node, s * 3, -iii * 0.3, 0.1, 2);
            }
          }
        }
      }
      // Legs + shoulders
      for (let ii = -1; ii <= 1; ii += 2) {
        let node = new Segment(spinal, s * 12, ii * 0.785, 0, 8);      // hip
        node = new Segment(node, s * 16, -ii * 0.785, 6.28, 1);        // humerus
        node = new Segment(node, s * 16, ii * 1.571, 3.1415, 2);       // forearm
        for (let iii = 0; iii < 4; iii++) {                            // fingers
          new Segment(
            node,
            s * 4,
            (iii / 3 - 0.5) * 1.571,
            0.1,
            4
          );
        }
        new LegSystem(node, 3, s * 12, critter, 4);
      }
    }

    // Tail
    for (let i = 0; i < tail; i++) {
      spinal = new Segment(spinal, s * 4, 0, (3.1415 * 2) / 3, 1.1);
      for (let ii = -1; ii <= 1; ii += 2) {
        let node = new Segment(spinal, s * 3, ii, 0.1, 2);
        for (let iii = 0; iii < 3; iii++) {
          node = new Segment(
            node,
            (s * 3 * (tail - i)) / tail,
            -ii * 0.1,
            0.1,
            2
          );
        }
      }
    }
  }

  // ====== АВТОПИЛОТ: МЕДЛЕННО ГУЛЯЕТ, ИНТЕЛЛИГЕНТНО ======
  const auto = {
    x: canvas.width / 2,
    y: canvas.height / 2,
    state: "wander", // wander | idle | circle
    targetX: canvas.width / 2,
    targetY: canvas.height / 2,
    timer: 0,
    duration: 0,
    circleAngle: 0,
    circleRadius: 80,
    circleCX: canvas.width / 2,
    circleCY: canvas.height / 2
  };

  function clampAuto() {
    const w = canvas.width;
    const h = canvas.height;
    auto.x = Math.max(BORDER_MARGIN, Math.min(w - BORDER_MARGIN, auto.x));
    auto.y = Math.max(BORDER_MARGIN, Math.min(h - BORDER_MARGIN, auto.y));
  }

  function setRandomTarget() {
    const angle = Math.random() * Math.PI * 2;
    const radius =
      AUTO_STEP_MIN + Math.random() * (AUTO_STEP_MAX - AUTO_STEP_MIN);
    auto.targetX = auto.x + Math.cos(angle) * radius;
    auto.targetY = auto.y + Math.sin(angle) * radius;

    const w = canvas.width;
    const h = canvas.height;
    auto.targetX = Math.max(BORDER_MARGIN, Math.min(w - BORDER_MARGIN, auto.targetX));
    auto.targetY = Math.max(BORDER_MARGIN, Math.min(h - BORDER_MARGIN, auto.targetY));
  }

  function updateAuto(dt) {
    auto.timer += dt;

    if (auto.state === "wander") {
      const dx = auto.targetX - auto.x;
      const dy = auto.targetY - auto.y;
      const dist = Math.hypot(dx, dy);
      const speed = AUTO_BASE_SPEED;

      if (dist < 10) {
        auto.timer = 0;
        const r = Math.random();
        if (r < 0.4) {
          auto.state = "idle";
          auto.duration =
            AUTO_IDLE_MIN +
            Math.random() * (AUTO_IDLE_MAX - AUTO_IDLE_MIN);
        } else if (r < 0.7) {
          auto.state = "circle";
          auto.duration = 2 + Math.random() * 3;
          auto.circleCX = auto.x;
          auto.circleCY = auto.y;
          auto.circleRadius =
            AUTO_RADIUS_MIN +
            Math.random() * (AUTO_RADIUS_MAX - AUTO_RADIUS_MIN);
          auto.circleAngle = Math.random() * Math.PI * 2;
        } else {
          setRandomTarget();
        }
      } else {
        const step = Math.min(speed * dt, dist);
        auto.x += (dx / dist) * step;
        auto.y += (dy / dist) * step;
        clampAuto();
      }
    } else if (auto.state === "idle") {
      if (auto.timer >= auto.duration) {
        auto.state = "wander";
        auto.timer = 0;
        setRandomTarget();
      } else {
        auto.x += Math.sin(auto.timer * 2.3) * 0.3;
        auto.y += Math.cos(auto.timer * 1.9) * 0.3;
        clampAuto();
      }
    } else if (auto.state === "circle") {
      auto.circleAngle += AUTO_CIRCLE_SPEED * dt;
      auto.x =
        auto.circleCX + Math.cos(auto.circleAngle) * auto.circleRadius;
      auto.y =
        auto.circleCY + Math.sin(auto.circleAngle) * auto.circleRadius;
      clampAuto();

      if (auto.timer >= auto.duration) {
        auto.state = "wander";
        auto.timer = 0;
        setRandomTarget();
      }
    }
  }

  // ====== УПРАВЛЕНИЕ И ЗАПУСК ======
  let isLizardEnabled = true;

  document.addEventListener('keydown', (event) => {
    if (event.key === 'l' || event.key === 'L' || event.key === 'д' || event.key === 'Д') {
      isLizardEnabled = !isLizardEnabled;
      const info = document.getElementById('toggle-info');
      if (isLizardEnabled) {
        canvas.style.display = 'block';
        info.style.display = 'block';
        lastTime = null; // Сброс времени, чтобы избежать скачка
        requestAnimationFrame(loop); // Перезапуск цикла
      } else {
        canvas.style.display = 'none';
        info.style.display = 'none';
      }
    }
  });

  // поменьше размер, но со всеми деталями
  const legs = 10;   // много лап — детализировано
  const size = 0.5;  // масштаб (если хочешь ещё меньше — сделай 0.4, 0.3 и т.п.)
  const tail = 80;   // длина хвоста (кол-во сегментов)

  setupLizard(size, legs, tail);

  let lastTime = null;
  function loop(time) {
    if (!isLizardEnabled) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      return; // Остановить цикл, если выключено
    }

    if (lastTime == null) lastTime = time;
    const dt = (time - lastTime) / 1000;
    lastTime = time;

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    updateAuto(dt);
    if (critter) {
      critter.follow(auto.x, auto.y);
    }
    requestAnimationFrame(loop);
  }
  setRandomTarget();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>